===== createCrudRouter.js =====
// createCrudRouter.js
const express = require('express');
const pool = require('./db');

/**
 * config = {
 *   table: 'shiftly_schema.tree_menu',
 *   idColumn: 'screen_id',
 *   columns: ['parent_id','screen_type','screen_file_name','menu_label']
 * }
 */
function createCrudRouter(config) {
  const router = express.Router();

  const allColumns = [config.idColumn, ...config.columns];

  // GET / -> list all rows
  router.get('/', async (req, res) => {
    try {
		
		      // Allow per-route custom list handler (filtering/pagination/etc.)
     if (typeof config.listHandler === 'function') {
       await config.listHandler(req, res, { pool, config, allColumns });
       return;
     }

      const query = `
        SELECT ${allColumns.join(', ')}
        FROM ${config.table}
        ORDER BY ${config.idColumn}
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (err) {
      console.error('Error querying DB (LIST):', err);
      res.status(500).json({ error: 'Database error' });
    }
  });

  // GET /:id -> single row
  router.get('/:id', async (req, res) => {
    try {
      const query = `
        SELECT ${allColumns.join(', ')}
        FROM ${config.table}
        WHERE ${config.idColumn} = $1
      `;
      const result = await pool.query(query, [req.params.id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Not found' });
      }

      res.json(result.rows[0]);
    } catch (err) {
      console.error('Error querying DB (GET BY ID):', err);
      res.status(500).json({ error: 'Database error' });
    }
  });

  // POST / -> insert (any subset of allowed columns)
  router.post('/', async (req, res) => {
    try {
      const cols = [];
      const placeholders = [];
      const values = [];
      let i = 1;

      for (const col of config.columns) {
        if (Object.prototype.hasOwnProperty.call(req.body, col)) {
          cols.push(col);
          placeholders.push(`$${i}`);
          values.push(req.body[col]);
          i++;
        }
      }

      if (cols.length === 0) {
        return res
          .status(400)
          .json({ error: 'No valid columns provided for insert' });
      }

      const query = `
        INSERT INTO ${config.table} (${cols.join(', ')})
        VALUES (${placeholders.join(', ')})
        RETURNING ${allColumns.join(', ')}
      `;

      const result = await pool.query(query, values);
      res.status(201).json(result.rows[0]);
    } catch (err) {
      console.error('Error inserting into DB (CREATE):', err);
      res.status(500).json({ error: 'Database error' });
    }
  });

  // PUT /:id -> update (any subset of allowed columns)
  router.put('/:id', async (req, res) => {
    try {
      const sets = [];
      const values = [];
      let i = 1;

      for (const col of config.columns) {
        if (Object.prototype.hasOwnProperty.call(req.body, col)) {
          sets.push(`${col} = $${i}`);
          values.push(req.body[col]);
          i++;
        }
      }

      if (sets.length === 0) {
        return res
          .status(400)
          .json({ error: 'No valid columns provided for update' });
      }

      values.push(req.params.id);
      const query = `
        UPDATE ${config.table}
        SET ${sets.join(', ')}
        WHERE ${config.idColumn} = $${i}
        RETURNING ${allColumns.join(', ')}
      `;

      const result = await pool.query(query, values);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Not found' });
      }

      res.json(result.rows[0]);
    } catch (err) {
      console.error('Error updating DB (UPDATE):', err);
      res.status(500).json({ error: 'Database error' });
    }
  });

  // DELETE /:id
  router.delete('/:id', async (req, res) => {
    try {
      const query = `
        DELETE FROM ${config.table}
        WHERE ${config.idColumn} = $1
        RETURNING ${allColumns.join(', ')}
      `;
      const result = await pool.query(query, [req.params.id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Not found' });
      }

      res.json({ deleted: result.rows[0] });
    } catch (err) {
      console.error('Error deleting from DB (DELETE):', err);
      res.status(500).json({ error: 'Database error' });
    }
  });

  return router;
}

module.exports = createCrudRouter;



===== db.js =====
// db.js
const { Pool } = require('pg');
require('dotenv').config(); // ensures env vars are loaded if used directly

const pool = new Pool({
  host: process.env.PGHOST,
  port: process.env.PGPORT,
  user: process.env.PGUSER,
  password: process.env.PGPASSWORD,
  database: process.env.PGDATABASE,
});

module.exports = pool;



===== hash_password.js =====
// hash_password.js
const bcrypt = require('bcrypt');

async function run() {
  const plainPassword = process.argv[2];

  if (!plainPassword) {
    console.error('Usage: node hash_password.js <password>');
    process.exit(1);
  }

  const saltRounds = 10;
  const hash = await bcrypt.hash(plainPassword, saltRounds);
  console.log('Plain password:', plainPassword);
  console.log('BCrypt hash   :', hash);
}

run().catch((err) => {
  console.error('Error while hashing:', err);
  process.exit(1);
});



===== index.js =====
// index.js
const express = require('express');
const cors = require('cors');
require('dotenv').config();


const treeMenuRouter = require('./routes/treeMenu');
const itemsRouter = require('./routes/items');
const departmentsRouter = require('./routes/departments');
const divisionsRouter = require('./routes/divisions');
const usersRouter = require('./routes/users');
const userDepartmentsRouter = require('./routes/userDepartments');
const userDivisionsRouter = require('./routes/userDivisions');
const authRouter = require('./routes/auth');

// new routes
const staffTypesRouter = require('./routes/staffTypes');
const shiftTypesRouter = require('./routes/shiftTypes');
const staffShiftRulesRouter = require('./routes/staffShiftRules');
const userManagersRouter = require('./routes/userManagers');
const shiftTemplatesRouter = require('./routes/shiftTemplates');
const shiftTemplateEntriesRouter = require('./routes/shiftTemplateEntries');
const shiftPeriodsRouter = require('./routes/shiftPeriods');
const shiftAssignmentsRouter = require('./routes/shiftAssignments');
const shiftRequestsRouter = require('./routes/shiftRequests');
const userAbsencesRouter = require('./routes/userAbsences');
const notifications = require('./routes/notifications');
const fcm = require('./routes/fcm');
const { startNotificationDispatcher } = require('./services/notificationDispatcher');

const app = express();
const port = process.env.API_PORT || 3000;

app.use(cors());
app.use(express.json());

app.get('/', (req, res) => {
  res.json({ message: 'API is working ✅' });
});

app.use('/auth', authRouter);

app.use('/tree-menu', treeMenuRouter);
app.use('/items', itemsRouter);
app.use('/departments', departmentsRouter);
app.use('/divisions', divisionsRouter);
app.use('/users', usersRouter);
app.use('/user-departments', userDepartmentsRouter);
app.use('/user-divisions', userDivisionsRouter);

// new mounts
app.use('/staff-types', staffTypesRouter);
app.use('/shift-types', shiftTypesRouter);
app.use('/staff-shift-rules', staffShiftRulesRouter);
app.use('/user-managers', userManagersRouter);
app.use('/shift-templates', shiftTemplatesRouter);
app.use('/shift-template-entries', shiftTemplateEntriesRouter);
app.use('/shift-periods', shiftPeriodsRouter);
app.use('/shift-assignments', shiftAssignmentsRouter);
app.use('/shift-requests', shiftRequestsRouter);
app.use('/user-absences', userAbsencesRouter);
app.use('/notifications', notifications);
app.use('/fcm', fcm);

app.listen(port, () => {
  console.log(`API listening on port ${port}`);
    // ✅ Start push dispatcher once API is up.
  startNotificationDispatcher().catch((e) => {
    console.error('Failed to start notification dispatcher:', e);
  });
});

module.exports = app;



===== make-merge.ps1 =====
$Output = "API_merged_shiftly_code.txt"

# Files / folders to exclude
$ExcludePaths = @(
    ".git",
    ".gitignore",
    "package-lock.json",
    "API_merged_shiftly_code.txt"
)

Write-Host "Merging all project files into $Output ..."
Write-Host "Excluded:"
$ExcludePaths | ForEach-Object { Write-Host " - $_" }
Write-Host ""

# Clear output file
if (Test-Path $Output) {
    Remove-Item $Output
}

# Get all files recursively
Get-ChildItem -Path . -Recurse -File | Sort-Object FullName | ForEach-Object {

    $RelativePath = $_.FullName.Replace((Get-Location).Path + "\", "")

    # Skip excluded paths
    foreach ($Exclude in $ExcludePaths) {
        if ($RelativePath -like "$Exclude*" -or $RelativePath -eq $Exclude) {
            return
        }
    }

    # Write file header
    Add-Content $Output "===== $RelativePath ====="

    # Write file content
    Get-Content $_.FullName | Add-Content $Output

    # Spacer
    Add-Content $Output "`n`n"
}

Write-Host "Done! File created: $Output"



===== package.json =====
{
  "name": "shiftly-api",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^6.0.0",
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "pg": "^8.16.3"
  }
}



===== routes\auth.js =====
// routes/auth.js
const express = require('express');
const bcrypt = require('bcryptjs');
const pool = require('../db');

const router = express.Router();

// Login endpoint: username = empno
router.post('/login', async (req, res) => {
  const { username, password } = req.body;

  if (!username || !password) {
    return res
      .status(400)
      .json({ error: 'Username and password are required.' });
  }

  try {
    const query = `
      SELECT id,
             empno,
             user_name,
             user_desc,
             user_type,
             role_id,
             password_hash
      FROM shiftly_schema.users
      WHERE empno = $1
    `;
    const result = await pool.query(query, [username]);

    if (result.rows.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials.' });
    }

    const user = result.rows[0];

    const passwordMatches = await bcrypt.compare(
      password,
      user.password_hash
    );

    if (!passwordMatches) {
      return res.status(401).json({ error: 'Invalid credentials.' });
    }

    // Do not send password_hash back to the client
    const { password_hash, ...safeUser } = user;

    return res.json(safeUser);
  } catch (err) {
    console.error('Error during login:', err);
    return res.status(500).json({ error: 'Database error' });
  }
});

// Change password endpoint
router.post('/change-password', async (req, res) => {
  const { userId, currentPassword, newPassword } = req.body;

  if (!userId || !currentPassword || !newPassword) {
    return res
      .status(400)
      .json({ error: 'userId, currentPassword and newPassword are required.' });
  }

  if (newPassword.length < 8) {
    return res.status(400).json({
      error: 'New password must be at least 8 characters long.',
    });
  }

  try {
    const selectQuery = `
      SELECT id, password_hash
      FROM shiftly_schema.users
      WHERE id = $1
    `;
    const selectResult = await pool.query(selectQuery, [userId]);

    if (selectResult.rows.length === 0) {
      return res.status(404).json({ error: 'User not found.' });
    }

    const user = selectResult.rows[0];

    const matches = await bcrypt.compare(
      currentPassword,
      user.password_hash
    );

    if (!matches) {
      return res
        .status(401)
        .json({ error: 'Current password is incorrect.' });
    }

    const newHash = await bcrypt.hash(newPassword, 10);

    const updateQuery = `
      UPDATE shiftly_schema.users
      SET password_hash = $1
      WHERE id = $2
    `;
    await pool.query(updateQuery, [newHash, userId]);

    return res.json({ message: 'Password updated successfully.' });
  } catch (err) {
    console.error('Error changing password:', err);
    return res.status(500).json({ error: 'Database error' });
  }
});

module.exports = router;



===== routes\departments.js =====
const createCrudRouter = require('../createCrudRouter');

const departmentsConfig = {
  table: 'shiftly_schema.departments',
  idColumn: 'id',
  columns: ['department_desc'],
};

module.exports = createCrudRouter(departmentsConfig);



===== routes\divisions.js =====
const createCrudRouter = require('../createCrudRouter');

const divisionsConfig = {
  table: 'shiftly_schema.divisions',
  idColumn: 'id',
  columns: ['division_desc'],
};

module.exports = createCrudRouter(divisionsConfig);



===== routes\fcm.js =====
const express = require('express');
const router = express.Router();
const pool = require('../db');

// POST /fcm/register
// { userId: 1, token: "...", platform: "android" }
router.post('/register', async (req, res) => {
  try {
    const userId = Number(req.body.userId);
    const token = String(req.body.token || '').trim();
    const platform = String(req.body.platform || '').trim();

    if (!userId) return res.status(400).json({ error: 'userId is required' });
    if (!token) return res.status(400).json({ error: 'token is required' });

    // Upsert by token (token must be unique).
    const sql = `
      INSERT INTO shiftly_schema.user_fcm_tokens (user_id, token, platform, updated_at)
      VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
      ON CONFLICT (token)
      DO UPDATE SET user_id = EXCLUDED.user_id,
                    platform = EXCLUDED.platform,
                    updated_at = CURRENT_TIMESTAMP
    `;

    await pool.query(sql, [userId, token, platform]);
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

module.exports = router;



===== routes\items.js =====
// routes/items.js
const express = require('express');
const pool = require('../db');

const router = express.Router();

// Existing items route (simple example)
router.get('/', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT id, name FROM items ORDER BY id'
    );
    res.json(result.rows);
  } catch (err) {
    console.error('Error querying DB (ITEMS LIST):', err);
    res.status(500).json({ error: 'Database error' });
  }
});

module.exports = router;



===== routes\notifications.js =====
const express = require('express');
const router = express.Router();

// Adjust these imports to your project structure:
const pool = require('../db'); // <- your pg Pool export


// GET /notifications?recipientUserId=1&unreadOnly=true
router.get('/', async (req, res) => {
  try {
    const recipientUserId = Number(req.query.recipientUserId);
    const unreadOnly = String(req.query.unreadOnly || 'false') === 'true';

    if (!recipientUserId) {
      return res.status(400).json({ error: 'recipientUserId is required' });
    }

    const params = [recipientUserId];
    let where = 'WHERE recipient_user_id = $1';
    if (unreadOnly) {
      where += ' AND is_read = false';
    }

    const sql = `
      SELECT id, recipient_user_id, notification_type, title, body, payload,
             is_read, created_at, read_at
      FROM shiftly_schema.notifications
      ${where}
      ORDER BY created_at DESC, id DESC
      LIMIT 500
    `;

    const { rows } = await pool.query(sql, params);
    res.json(rows);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// POST /notifications/:id/read
router.post('/:id/read', async (req, res) => {
  try {
    const id = Number(req.params.id);
    if (!id) return res.status(400).json({ error: 'invalid id' });

    const sql = `
      UPDATE shiftly_schema.notifications
      SET is_read = true, read_at = CURRENT_TIMESTAMP
      WHERE id = $1
      RETURNING *
    `;
    const { rows } = await pool.query(sql, [id]);
    res.json(rows[0] || null);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// POST /notifications/mark-all-read  { recipientUserId: 1 }
router.post('/mark-all-read', async (req, res) => {
  try {
    const recipientUserId = Number(req.body.recipientUserId);
    if (!recipientUserId) {
      return res.status(400).json({ error: 'recipientUserId is required' });
    }
    const sql = `
      UPDATE shiftly_schema.notifications
      SET is_read = true, read_at = CURRENT_TIMESTAMP
      WHERE recipient_user_id = $1 AND is_read = false
    `;
    await pool.query(sql, [recipientUserId]);
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// POST /notifications/push
// Body:
//  - title (required)
//  - body (optional)
//  - recipientUserId (optional)
//  - departmentId (optional)
//  - payload (optional JSON)
// Creates MANUAL notifications for a specific user or all users in a department.
router.post('/push', async (req, res) => {
  try {
    const title = String(req.body.title || '').trim();
    const body = (req.body.body == null) ? null : String(req.body.body);
    const recipientUserId = req.body.recipientUserId == null ? null : Number(req.body.recipientUserId);
    const departmentId = req.body.departmentId == null ? null : Number(req.body.departmentId);
    const payload = req.body.payload == null ? null : req.body.payload;

    if (!title) return res.status(400).json({ error: 'title is required' });
    if (!recipientUserId && !departmentId) {
      return res.status(400).json({ error: 'recipientUserId or departmentId is required' });
    }

    let userIds = [];
    if (recipientUserId) {
      userIds = [recipientUserId];
    } else {
      // Adjust table name if yours differs:
      // We assume: shiftly_schema.user_departments(user_id, department_id)
      const { rows } = await pool.query(
        `SELECT DISTINCT user_id FROM shiftly_schema.user_department WHERE department_id = $1`,
        [departmentId]
      );
      userIds = rows.map(r => r.user_id);
    }

    if (userIds.length === 0) return res.json({ ok: true, inserted: 0 });

    const insertSql = `
      INSERT INTO shiftly_schema.notifications
        (recipient_user_id, notification_type, title, body, payload)
      VALUES ($1, 'MANUAL', $2, $3, $4)
    `;

    for (const uid of userIds) {
      await pool.query(insertSql, [uid, title, body, payload]);
    }
	
    // ✅ NO direct FCM here anymore.
    // ALL pushes (manual + trigger-generated) are sent by notificationDispatcher
    // when rows are inserted into shiftly_schema.notifications.
    res.json({ ok: true, inserted: userIds.length });

  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

module.exports = router;



===== routes\shiftAssignments.js =====
// routes/shiftAssignments.js
const createCrudRouter = require('../createCrudRouter');

const shiftAssignmentsConfig = {
  table: 'shiftly_schema.shift_assignments',
  idColumn: 'id',
  columns: [
    'shift_period_id',
    'shift_date',
    'department_id',
    'user_id',
    'staff_type_id',
    'shift_type_id',
    'source_type',
    'status',
    'status_comment',
	 'is_absence',
     'absence_type',
    'created_at',
    'updated_at',
	'staff_shift_rule_id',
    'required_staff_snapshot',
  ],
  
    // GET /shift-assignments?shift_period_id=123&start_date=YYYY-MM-DD&end_date=YYYY-MM-DD&limit=...&offset=...
  listHandler: async (req, res, { pool, config, allColumns }) => {
    const qp = req.query || {};

    const rawPeriod = qp.shift_period_id ?? qp.shiftPeriodId;
    const shiftPeriodId = rawPeriod != null ? Number(rawPeriod) : null;

    const startDate = (qp.start_date ?? qp.startDate ?? '').toString().trim();
    const endDate = (qp.end_date ?? qp.endDate ?? '').toString().trim();

    const limit = qp.limit != null ? Number(qp.limit) : null;
    const offset = qp.offset != null ? Number(qp.offset) : null;

    const where = [];
    const params = [];
    let i = 1;

    if (shiftPeriodId && Number.isFinite(shiftPeriodId)) {
      params.push(shiftPeriodId);
      where.push(`shift_period_id = $${i++}`);
    }
    if (startDate) {
      params.push(startDate);
      where.push(`shift_date >= $${i++}`);
    }
    if (endDate) {
      params.push(endDate);
      where.push(`shift_date <= $${i++}`);
    }

    let sql = `
      SELECT ${allColumns.join(', ')}
      FROM ${config.table}
    `;
    if (where.length) {
      sql += ` WHERE ${where.join(' AND ')}`;
    }
    sql += ` ORDER BY shift_date ASC, id ASC`;

    if (limit && Number.isFinite(limit)) {
      params.push(limit);
      sql += ` LIMIT $${i++}`;
    }
    if (offset && Number.isFinite(offset)) {
      params.push(offset);
      sql += ` OFFSET $${i++}`;
    }

    const result = await pool.query(sql, params);
    res.json(result.rows);
  },
  
  
};

module.exports = createCrudRouter(shiftAssignmentsConfig);



===== routes\shiftPeriods.js =====
// routes/shiftPeriods.js
const express = require('express');
const pool = require('../db');
const createCrudRouter = require('../createCrudRouter');

const shiftPeriodsConfig = {
  table: 'shiftly_schema.shift_periods',
  idColumn: 'id',
  columns: [
    'period_type',
    'start_date',
    'end_date',
    'template_id',
    'generated_at',
    'generated_by_user_id',
    'status',
    'description',
  ],
};
const router = createCrudRouter(shiftPeriodsConfig);

/**
 * Helper: convert JS Date -> ISO YYYY-MM-DD (no time part)
 */
function formatYmd(date) {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, '0');
  const d = String(date.getDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

/**
 * Helper: Monday = 1, Sunday = 7
 */
function isoWeekday(date) {
  const jsDay = date.getDay(); // 0..6, Sunday = 0
  return jsDay === 0 ? 7 : jsDay;
}

/**
 * Helper: week index in month, 1-based (1..4/5)
 * Same logic as in Flutter: ((day-1) ~/ 7) + 1
 */
function weekIndexInMonth(date) {
  return Math.floor((date.getDate() - 1) / 7) + 1;
}

/**
 * Helper: normalize week_of_cycle for multi-week patterns
 */
function weekOfCycleForDate(date, cycleLengthWeeks) {
  const index = weekIndexInMonth(date);
  const length = cycleLengthWeeks && cycleLengthWeeks > 0
    ? cycleLengthWeeks
    : 1;
  return ((index - 1) % length) + 1;
}

/**
 * POST /shift-periods/:id/generate-from-template
 *
 * This endpoint:
 *   1) Loads the shift_period and its template_id
 *   2) Loads the template + template entries
 *   3) Deletes existing TEMPLATE-based assignments for this period
 *   4) Loops over all days in the period and inserts shift_assignments
 *      wherever the (day_of_week, week_of_cycle) from the template matches.
 *
 * Expected DB columns (aligned with the Flutter models):
 *   shift_templates:
 *     - id
 *     - pattern_type         ('WEEKLY' or 'WEEKLY_CYCLE')
 *     - cycle_length_weeks   (integer)
 *   shift_template_entries:
 *     - template_id
 *     - department_id
 *     - staff_type_id
 *     - user_id
 *     - shift_type_id
 *     - day_of_week          (1..7, Monday = 1)
 *     - week_of_cycle        (1..N, for WEEKLY_CYCLE; for WEEKLY typically 1)
 */
router.post('/:id/generate-from-template', async (req, res) => {
  const periodId = parseInt(req.params.id, 10);

  if (Number.isNaN(periodId)) {
    return res.status(400).json({ error: 'Invalid period id.' });
  }

  let client;

  try {
    client = await pool.connect();
    await client.query('BEGIN');

    // 1) Load the shift_period
    const periodQuery = `
      SELECT *
      FROM shiftly_schema.shift_periods
      WHERE id = $1
      FOR UPDATE
    `;
    const periodResult = await client.query(periodQuery, [periodId]);

    if (periodResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Shift period not found.' });
    }

    const period = periodResult.rows[0];

    if (!period.template_id) {
      await client.query('ROLLBACK');
      return res.status(400).json({
        error: 'Shift period has no template_id. Nothing to generate from.',
      });
    }

    // 2) Load the template
    const templateQuery = `
      SELECT id, pattern_type, cycle_length_weeks
      FROM shiftly_schema.shift_templates
      WHERE id = $1
    `;
    const templateResult = await client.query(templateQuery, [
      period.template_id,
    ]);

    if (templateResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(400).json({
        error: `Template ${period.template_id} not found.`,
      });
    }

    const template = templateResult.rows[0];

    // 3) Load template entries for this template
    const entriesQuery = `
      SELECT
        id,
        template_id,
        department_id,
        staff_type_id,
        user_id,
        shift_type_id,
        day_of_week,
        week_of_cycle
      FROM shiftly_schema.shift_template_entries
      WHERE template_id = $1
    `;
    const entriesResult = await client.query(entriesQuery, [template.id]);
    const entries = entriesResult.rows;

    // Remove existing TEMPLATE-based assignments for this period
    const deleteAssignmentsQuery = `
      DELETE FROM shiftly_schema.shift_assignments
      WHERE shift_period_id = $1
        AND source_type = 'TEMPLATE'
    `;
    await client.query(deleteAssignmentsQuery, [periodId]);

    // 4) Loop dates in the period and insert assignments
    const startDate = new Date(period.start_date);
    const endDate = new Date(period.end_date);

    if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) {
      await client.query('ROLLBACK');
      return res.status(400).json({
        error: 'Invalid start_date or end_date in shift_period.',
      });
    }

    let current = new Date(startDate);
    let insertedCount = 0;

    while (current <= endDate) {
      const dayOfWeek = isoWeekday(current);
      const weekOfCycle = template.pattern_type === 'WEEKLY'
        ? 1
        : weekOfCycleForDate(current, template.cycle_length_weeks);

      const matchingEntries = entries.filter(
        (e) =>
          e.day_of_week === dayOfWeek &&
          (e.week_of_cycle === null || e.week_of_cycle === weekOfCycle),
      );

      for (const e of matchingEntries) {
        const shiftDateStr = formatYmd(current);

        const insertAssignmentQuery = `
          INSERT INTO shiftly_schema.shift_assignments
          (
            shift_period_id,
            shift_date,
            department_id,
            user_id,
            staff_type_id,
            shift_type_id,
            source_type,
            status,
            status_comment,
            created_at,
            updated_at
          )
          VALUES
          (
            $1,
            $2,
            $3,
            $4,
            $5,
            $6,
            'TEMPLATE',
            'GENERATED',
            NULL,
            NOW(),
            NOW()
          )
        `;

        const insertValues = [
          periodId,
          shiftDateStr,
          e.department_id,
          e.user_id,
          e.staff_type_id,
          e.shift_type_id,
        ];

        await client.query(insertAssignmentQuery, insertValues);
        insertedCount += 1;
      }

      // advance one day
      current.setDate(current.getDate() + 1);
    }

    await client.query('COMMIT');

    return res.json({
      message: 'Assignments generated from template.',
      period_id: periodId,
      template_id: template.id,
      inserted_count: insertedCount,
    });
  } catch (err) {
    if (client) {
      try {
        await client.query('ROLLBACK');
      } catch (rollbackErr) {
        console.error('Error during ROLLBACK:', rollbackErr);
      }
    }
       console.error('Error generating assignments from template:', err);
    return res.status(500).json({
      error: 'Database error',
      // typical PG error fields (if available)
      details: err.message,
      code: err.code,
      routine: err.routine,
    });
  } finally {
    if (client) {
      client.release();
    }
  }
});

module.exports = router;



===== routes\shiftRequests.js =====

const express = require('express');
const pool = require('../db');

const router = express.Router();

/**
 * GET /shift-requests
 *
 * Optional query parameters:
 *  - managerUserId: show items for this manager (either directly assigned via manager_user_id
 *    OR where this manager is the primary manager in shiftly_schema.user_managers).
 *  - requestedByUserId: filter by the requesting user id.
 *  - requestStatus: filter by status (PENDING, APPROVED, REJECTED, ...).
 */
router.get('/', async (req, res) => {
  try {
    const { managerUserId, requestedByUserId, requestStatus } = req.query;

    const whereClauses = [];
    const values = [];

    if (requestedByUserId) {
      values.push(parseInt(requestedByUserId, 10));
      whereClauses.push(`sr.requested_by_user_id = $${values.length}`);
    }

    if (requestStatus) {
      values.push(requestStatus);
      whereClauses.push(`sr.request_status = $${values.length}`);
    }

    if (managerUserId) {
      const managerId = parseInt(managerUserId, 10);
      values.push(managerId);
      const index = values.length;

      // Match either directly by sr.manager_user_id OR via user_managers mapping
      whereClauses.push(
        `(sr.manager_user_id = $${index}
           OR EXISTS (
             SELECT 1
               FROM shiftly_schema.user_managers um
              WHERE um.user_id = sr.requested_by_user_id
                AND um.manager_user_id = $${index}
                AND um.is_primary = TRUE
           ))`
      );
    }

    const whereSql =
      whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';

    const query = `
      SELECT
        sr.id,
        sr.request_type,
        sr.request_status,
        sr.requested_by_user_id,
        sr.target_user_id,
        sr.manager_user_id,
        sr.shift_assignment_id,
        sr.requested_shift_date,
        sr.requested_shift_type_id,
        sr.requested_department_id,
        sr.created_at,
        sr.decided_at,
        sr.decision_by_user_id,
        sr.decision_comment
      FROM shiftly_schema.shift_requests sr
      ${whereSql}
      ORDER BY sr.created_at DESC
    `;

    const result = await pool.query(query, values);
    res.json(result.rows);
  } catch (err) {
    console.error('Error querying DB (SHIFT REQUESTS LIST):', err);
    res.status(500).json({ error: 'Database error' });
  }
});

/**
 * POST /shift-requests
 *
 * Body:
 *  - request_type (required)
 *  - requested_by_user_id (required)
 *  - target_user_id (optional)
 *  - manager_user_id (optional – if missing, we try to derive it from user_managers)
 *  - shift_assignment_id (optional)
 *  - requested_shift_date (required, YYYY-MM-DD)
 *  - requested_shift_type_id (required)
 *  - requested_department_id (required)
 *  - decision_comment (optional, used here as "request comment" from employee)
 */
router.post('/', async (req, res) => {
  try {
    const {
      request_type,
      requested_by_user_id,
      target_user_id,
      manager_user_id,
      shift_assignment_id,
      requested_shift_date,
      requested_shift_type_id,
      requested_department_id,
      decision_comment,
    } = req.body;

    if (
      !request_type ||
      !requested_by_user_id ||
      !requested_shift_date ||
      !requested_shift_type_id ||
      !requested_department_id
    ) {
      return res.status(400).json({
        error:
          'request_type, requested_by_user_id, requested_shift_date, requested_shift_type_id and requested_department_id are required.',
      });
    }

    let effectiveManagerId = manager_user_id ?? null;

    // If manager_user_id is not provided, try to get the primary manager
    // from shiftly_schema.user_managers.
    if (!effectiveManagerId) {
      const managerResult = await pool.query(
        `
          SELECT manager_user_id
            FROM shiftly_schema.user_managers
           WHERE user_id = $1
             AND is_primary = TRUE
           ORDER BY id
           LIMIT 1
        `,
        [requested_by_user_id]
      );

      if (managerResult.rows.length > 0) {
        effectiveManagerId = managerResult.rows[0].manager_user_id;
      }
    }

    const insertQuery = `
      INSERT INTO shiftly_schema.shift_requests (
        request_type,
        request_status,
        requested_by_user_id,
        target_user_id,
        manager_user_id,
        shift_assignment_id,
        requested_shift_date,
        requested_shift_type_id,
        requested_department_id,
        created_at,
        decided_at,
        decision_by_user_id,
        decision_comment
      )
      VALUES (
        $1,         -- request_type
        'PENDING',  -- request_status
        $2,         -- requested_by_user_id
        $3,         -- target_user_id
        $4,         -- manager_user_id (can be null if no mapping exists)
        $5,         -- shift_assignment_id
        $6,         -- requested_shift_date
        $7,         -- requested_shift_type_id
        $8,         -- requested_department_id
        NOW(),      -- created_at
        NULL,       -- decided_at
        NULL,       -- decision_by_user_id
        $9          -- decision_comment (request comment)
      )
      RETURNING
        id,
        request_type,
        request_status,
        requested_by_user_id,
        target_user_id,
        manager_user_id,
        shift_assignment_id,
        requested_shift_date,
        requested_shift_type_id,
        requested_department_id,
        created_at,
        decided_at,
        decision_by_user_id,
        decision_comment
    `;

    const insertValues = [
      request_type,
      requested_by_user_id,
      target_user_id ?? null,
      effectiveManagerId,
      shift_assignment_id ?? null,
      requested_shift_date,
      requested_shift_type_id,
      requested_department_id,
      decision_comment ?? null,
    ];

    const result = await pool.query(insertQuery, insertValues);
    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error('Error inserting into DB (SHIFT REQUESTS CREATE):', err);
    res.status(500).json({ error: 'Database error' });
  }
});

/**
 * POST /shift-requests/:id/approve
 *
 * Body:
 *  - decision_by_user_id (required, manager user id)
 *  - decision_comment (optional)
 */
router.post('/:id/approve', async (req, res) => {
  try {
    const { id } = req.params;
    const { decision_by_user_id, decision_comment } = req.body;

    if (!decision_by_user_id) {
      return res.status(400).json({
        error: 'decision_by_user_id is required to approve a request.',
      });
    }

    const query = `
      UPDATE shiftly_schema.shift_requests
         SET request_status      = 'APPROVED',
             decided_at          = NOW(),
             decision_by_user_id = $1,
             decision_comment    = $2
       WHERE id = $3
       RETURNING
         id,
         request_type,
         request_status,
         requested_by_user_id,
         target_user_id,
         manager_user_id,
         shift_assignment_id,
         requested_shift_date,
         requested_shift_type_id,
         requested_department_id,
         created_at,
         decided_at,
         decision_by_user_id,
         decision_comment
    `;

    const values = [decision_by_user_id, decision_comment ?? null, id];

    const result = await pool.query(query, values);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Not found' });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error approving shift request:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

/**
 * POST /shift-requests/:id/reject
 *
 * Body:
 *  - decision_by_user_id (required, manager user id)
 *  - decision_comment (optional)
 */
router.post('/:id/reject', async (req, res) => {
  try {
    const { id } = req.params;
    const { decision_by_user_id, decision_comment } = req.body;

    if (!decision_by_user_id) {
      return res.status(400).json({
        error: 'decision_by_user_id is required to reject a request.',
      });
    }

    const query = `
      UPDATE shiftly_schema.shift_requests
         SET request_status      = 'REJECTED',
             decided_at          = NOW(),
             decision_by_user_id = $1,
             decision_comment    = $2
       WHERE id = $3
       RETURNING
         id,
         request_type,
         request_status,
         requested_by_user_id,
         target_user_id,
         manager_user_id,
         shift_assignment_id,
         requested_shift_date,
         requested_shift_type_id,
         requested_department_id,
         created_at,
         decided_at,
         decision_by_user_id,
         decision_comment
    `;

    const values = [decision_by_user_id, decision_comment ?? null, id];

    const result = await pool.query(query, values);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Not found' });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error rejecting shift request:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

module.exports = router;





===== routes\shiftTemplateEntries.js =====
// routes/shiftTemplateEntries.js
const createCrudRouter = require('../createCrudRouter');

const shiftTemplateEntriesConfig = {
  table: 'shiftly_schema.shift_template_entries',
  idColumn: 'id',
 columns: [
   'template_id',
   'division_id',
   'department_id',
   'staff_type_id',
   'user_id',
   'shift_type_id',
   'day_of_week',
   'week_of_cycle',
 ],
};

module.exports = createCrudRouter(shiftTemplateEntriesConfig);



===== routes\shiftTemplates.js =====
// routes/shiftTemplates.js
const createCrudRouter = require('../createCrudRouter');

const shiftTemplatesConfig = {
  table: 'shiftly_schema.shift_templates',
  idColumn: 'id',
  columns: [
    'template_name',
    'pattern_type',
    'cycle_length_weeks',
    'cycle_anchor_date',
    'is_active',
    'description',
  ],
};

module.exports = createCrudRouter(shiftTemplatesConfig);



===== routes\shiftTypes.js =====
// routes/shiftTypes.js
const createCrudRouter = require('../createCrudRouter');

const shiftTypesConfig = {
  table: 'shiftly_schema.shift_types',
  idColumn: 'id',
  columns: [
    'shift_code',
    'shift_label',
    'start_time',
    'end_time',
    'duration_hours',
    'day_type',
    'notes',
  ],
};

module.exports = createCrudRouter(shiftTypesConfig);



===== routes\staffShiftRules.js =====
// routes/staffShiftRules.js
const createCrudRouter = require('../createCrudRouter');

const staffShiftRulesConfig = {
  table: 'shiftly_schema.staff_shift_rules',
  idColumn: 'id',
  columns: [
    'division_id',
    'department_id',
    'staff_type_id',
    'shift_type_id',
    'required_staff_count',
  ],
};

module.exports = createCrudRouter(staffShiftRulesConfig);



===== routes\staffTypes.js =====
// routes/staffTypes.js
const createCrudRouter = require('../createCrudRouter');

const staffTypesConfig = {
  table: 'shiftly_schema.staff_types',
  idColumn: 'id',
  columns: ['staff_type_name'],
};

module.exports = createCrudRouter(staffTypesConfig);



===== routes\treeMenu.js =====
// routes/treeMenu.js
const createCrudRouter = require('../createCrudRouter');

const treeMenuConfig = {
  table: 'shiftly_schema.tree_menu',
  idColumn: 'screen_id',
  columns: ['parent_id', 'screen_type', 'screen_file_name', 'menu_label'],
};

module.exports = createCrudRouter(treeMenuConfig);



===== routes\userAbsences.js =====
// Path: d:\Cloned_REPOS\shiftly-api\routes\userAbsences.js
// (adjust base folder name if your API repo path is different)

const createCrudRouter = require('../createCrudRouter');

const userAbsencesConfig = {
  table: 'shiftly_schema.user_absences',
  idColumn: 'id',
  columns: [
    'user_id',
    'absence_type',
    'start_date',
    'end_date',
    'created_by',
    'comment',
  ],
};

module.exports = createCrudRouter(userAbsencesConfig);




===== routes\userDepartments.js =====
const createCrudRouter = require('../createCrudRouter');

const userDepartmentsConfig = {
  table: 'shiftly_schema.user_department',
  idColumn: 'id',
  columns: ['user_id', 'department_id', 'department_desc'],
};

module.exports = createCrudRouter(userDepartmentsConfig);



===== routes\userDivisions.js =====
const createCrudRouter = require('../createCrudRouter');

const userDivisionsConfig = {
  table: 'shiftly_schema.user_divisions',
  idColumn: 'id',
  columns: ['user_id', 'division_id', 'division_desc'],
};

module.exports = createCrudRouter(userDivisionsConfig);



===== routes\userManagers.js =====
// routes/userManagers.js
const createCrudRouter = require('../createCrudRouter');

const userManagersConfig = {
  table: 'shiftly_schema.user_managers',
  idColumn: 'id',
  columns: ['user_id', 'manager_user_id', 'is_primary'],
};

module.exports = createCrudRouter(userManagersConfig);



===== routes\users.js =====
// routes/users.js
const express = require('express');
const bcrypt = require('bcryptjs');
const pool = require('../db');

const router = express.Router();

// GET /users -> list all users (without password_hash)
router.get('/', async (req, res) => {
  try {
    const query = `
      SELECT id,
             empno,
             user_name,
             user_desc,
             user_type,
             role_id,
			 staff_type_id
      FROM shiftly_schema.users
      ORDER BY id
    `;
    const result = await pool.query(query);
    res.json(result.rows);
  } catch (err) {
    console.error('Error querying DB (USERS LIST):', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// GET /users/:id -> single user (without password_hash)
router.get('/:id', async (req, res) => {
  try {
    const query = `
      SELECT id,
             empno,
             user_name,
             user_desc,
             user_type,
             role_id,
			 staff_type_id
      FROM shiftly_schema.users
      WHERE id = $1
    `;
    const result = await pool.query(query, [req.params.id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Not found' });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error querying DB (USERS GET BY ID):', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// POST /users -> create a new user with hashed password
router.post('/', async (req, res) => {
  try {
    const {
      empno,
      user_name,
      user_desc,
      user_type,
      role_id,
	  staff_type_id,
      password,
    } = req.body;

    if (!empno || !user_name || !user_type || !password) {
      return res.status(400).json({
        error:
          'empno, user_name, user_type and password are required to create a user.',
      });
    }

    if (password.length < 8) {
      return res.status(400).json({
        error: 'Password must be at least 8 characters long.',
      });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    const query = `
      INSERT INTO shiftly_schema.users
        (empno, user_name, user_desc, user_type, role_id, staff_type_id, password_hash)
      VALUES
        ($1,    $2,        $3,        $4,        $5,      $6,      $7)
      RETURNING id,
                empno,
                user_name,
                user_desc,
                user_type,
                role_id,
				staff_type_id
    `;

    const values = [
      empno,
      user_name,
      user_desc ?? null,
      user_type,
      role_id ?? null,
	  staff_type_id ?? null,
      hashedPassword,
    ];

    const result = await pool.query(query, values);
    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error('Error inserting into DB (USERS CREATE):', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// PUT /users/:id -> update user data (without changing password)
router.put('/:id', async (req, res) => {
  try {
    const {
      empno,
      user_name,
      user_desc,
      user_type,
      role_id,
	  staff_type_id,
    } = req.body;

    if (!empno || !user_name || !user_type) {
      return res.status(400).json({
        error: 'empno, user_name and user_type are required for update.',
      });
    }

    const query = `
      UPDATE shiftly_schema.users
      SET empno = $1,
          user_name = $2,
          user_desc = $3,
          user_type = $4,
          role_id = $5,
		  staff_type_id = $6
      WHERE id = $7
      RETURNING id,
                empno,
                user_name,
                user_desc,
                user_type,
                role_id,
				staff_type_id
    `;

    const values = [
      empno,
      user_name,
      user_desc ?? null,
      user_type,
      role_id ?? null,
	  staff_type_id ?? null,
      req.params.id,
    ];

    const result = await pool.query(query, values);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Not found' });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error updating DB (USERS UPDATE):', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// DELETE /users/:id -> delete user
router.delete('/:id', async (req, res) => {
  try {
    const query = `
      DELETE FROM shiftly_schema.users
      WHERE id = $1
      RETURNING id,
                empno,
                user_name,
                user_desc,
                user_type,
                role_id,
				staff_type_id
    `;
    const result = await pool.query(query, [req.params.id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Not found' });
    }

    res.json({ deleted: result.rows[0] });
  } catch (err) {
    console.error('Error deleting from DB (USERS DELETE):', err);
    res.status(500).json({ error: 'Database error' });
  }
});

module.exports = router;



===== services\firebaseAdmin.js =====
const admin = require('firebase-admin');
const pool = require('../db');
const fs = require('fs');
let _inited = false;

function initFirebase() {
  if (_inited) return;

  // Option A: Use GOOGLE_APPLICATION_CREDENTIALS=/path/serviceAccount.json
  // Option B: Use FIREBASE_SERVICE_ACCOUNT_JSON='{"type":"service_account",...}'
  if (process.env.FIREBASE_SERVICE_ACCOUNT_JSON) {
    const json = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT_JSON);
    admin.initializeApp({ credential: admin.credential.cert(json) });
  } else {
	  const p = process.env.GOOGLE_APPLICATION_CREDENTIALS;
   if (p && !fs.existsSync(p)) {
     throw new Error(`GOOGLE_APPLICATION_CREDENTIALS file not found: ${p}`);
   }
    admin.initializeApp({ credential: admin.credential.applicationDefault() });
  }

  _inited = true;
}

async function getTokensForUsers(userIds) {
  if (!userIds || userIds.length === 0) return [];
  const { rows } = await pool.query(
    `SELECT token FROM shiftly_schema.user_fcm_tokens WHERE user_id = ANY($1::int[])`,
    [userIds]
  );
  return rows.map(r => r.token).filter(Boolean);
}

async function removeBadTokens(tokens) {
  if (!tokens || tokens.length === 0) return;
  await pool.query(
    `DELETE FROM shiftly_schema.user_fcm_tokens WHERE token = ANY($1::text[])`,
    [tokens]
  );
}

async function sendToUsers({ userIds, title, body, data }) {
  initFirebase();

  const tokens = await getTokensForUsers(userIds);
  if (tokens.length === 0) return { ok: true, sent: 0 };

  // FCM data values must be strings.
  const dataStrings = {};
  if (data && typeof data === 'object') {
    for (const [k, v] of Object.entries(data)) {
      if (v == null) continue;
      dataStrings[k] = typeof v === 'string' ? v : JSON.stringify(v);
    }
  }

  // Multicast max 500 tokens per request
  let sent = 0;
  const badTokens = [];

  for (let i = 0; i < tokens.length; i += 500) {
    const chunk = tokens.slice(i, i + 500);
    const resp = await admin.messaging().sendEachForMulticast({
      tokens: chunk,
      notification: {
        title: String(title || 'Shiftly'),
        body: String(body || ''),
      },
      data: dataStrings,
      android: {
        priority: 'high',
      },
    });

    sent += resp.successCount;

    resp.responses.forEach((r, idx) => {
      if (!r.success) {
        const code = r.error?.code || '';
        if (
          code.includes('registration-token-not-registered') ||
          code.includes('invalid-registration-token')
        ) {
          badTokens.push(chunk[idx]);
        }
      }
    });
  }

  await removeBadTokens(badTokens);
  return { ok: true, sent };
}

module.exports = { sendToUsers };



===== services\notificationDispatcher.js =====
const { Client } = require('pg');
const pool = require('../db');
const { sendToUsers } = require('./firebaseAdmin');

const CHANNEL = 'shiftly_notification_inserted';

let _started = false;
let _client = null;

function _safeJsonParse(s) {
  try {
    return JSON.parse(s);
  } catch (_) {
    return null;
  }
}

async function _dispatchByNotificationId(notificationId) {
  // Keep transaction open while sending to avoid duplicates across concurrent notifies.
  await _client.query('BEGIN');
  try {
    const { rows } = await _client.query(
      `
      SELECT
        id,
        recipient_user_id,
        notification_type,
        title,
        body,
        payload,
        push_sent_at,
        push_attempts
      FROM shiftly_schema.notifications
      WHERE id = $1
      FOR UPDATE
      `,
      [notificationId],
    );

    const n = rows[0];
    if (!n) {
      await _client.query('COMMIT');
      return;
    }

    // already sent
    if (n.push_sent_at) {
      await _client.query('COMMIT');
      return;
    }

    // stop retrying after a few attempts
    if ((n.push_attempts ?? 0) >= 5) {
      await _client.query('COMMIT');
      return;
    }

    // Build FCM data payload (MUST be strings; firebaseAdmin.js already stringifies)
    const data = {};
    if (n.payload && typeof n.payload === 'object') {
      Object.assign(data, n.payload);
    }
    if (!data.route) data.route = '/notifications';
    data.type = n.notification_type || 'UNKNOWN';
    data.notificationId = String(n.id);
    data.recipientUserId = String(n.recipient_user_id);

    let sent = 0;
    let errText = null;

    try {
      const resp = await sendToUsers({
        userIds: [n.recipient_user_id],
        title: n.title || 'Shiftly',
        body: n.body || '',
        data,
      });
      sent = resp?.sent ?? 0;
    } catch (err) {
      errText = err?.message || String(err);
      console.error('FCM dispatch error:', errText);
    }

    if (sent > 0) {
      await _client.query(
        `
        UPDATE shiftly_schema.notifications
        SET push_sent_at = CURRENT_TIMESTAMP,
            push_attempts = push_attempts + 1,
            last_push_error = NULL
        WHERE id = $1
        `,
        [n.id],
      );
    } else {
      await _client.query(
        `
        UPDATE shiftly_schema.notifications
        SET push_attempts = push_attempts + 1,
            last_push_error = $2
        WHERE id = $1
        `,
        [n.id, errText || 'NO_TOKENS_OR_NOT_DELIVERED'],
      );
    }

    await _client.query('COMMIT');
  } catch (e) {
    await _client.query('ROLLBACK');
    console.error('Notification dispatcher failed:', e);
  }
}

async function _drainPending(limit = 100) {
  // Drain older pending rows (covers: API restart, token registered later, missed NOTIFY, etc.)
  const { rows } = await pool.query(
    `
    SELECT id
    FROM shiftly_schema.notifications
    WHERE push_sent_at IS NULL
      AND push_attempts < 5
    ORDER BY id ASC
    LIMIT $1
    `,
    [limit],
  );

  for (const r of rows) {
    await _dispatchByNotificationId(Number(r.id));
  }
}

async function startNotificationDispatcher() {
  if (_started) return;
  _started = true;

  _client = new Client(); // uses PG* env vars (same as your pool)
  await _client.connect();

  await _client.query(`LISTEN ${CHANNEL}`);
  console.log(`[dispatcher] LISTEN ${CHANNEL}`);

  // Initial drain on boot (in case app was down)
  _drainPending().catch((e) => console.error('[dispatcher] drain error:', e));

  // Periodic drain (keeps things robust)
  setInterval(() => {
    _drainPending().catch((e) => console.error('[dispatcher] drain error:', e));
  }, 60 * 1000);

  _client.on('notification', (msg) => {
    if (!msg || msg.channel !== CHANNEL) return;
    const p = _safeJsonParse(msg.payload || '');
    const id = Number(p?.notificationId);
    if (!id) return;

    // fire-and-forget (serialized by awaiting inside _dispatch)
    _dispatchByNotificationId(id).catch((e) =>
      console.error('[dispatcher] dispatch error:', e),
    );
  });

  _client.on('error', (err) => {
    console.error('[dispatcher] PG client error:', err);
  });
}

module.exports = { startNotificationDispatcher };



